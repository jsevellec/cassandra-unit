From 9474c9a6a836d7e831a0315259cd2d8c8eb7a8e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc=20CARR=C3=89?= <carre.marc@gmail.com>
Date: Tue, 15 Jan 2013 06:32:36 +0000
Subject: [PATCH] Binary data can now be formatted as Base64 encoded strings in
 data-set files.

** Rationale **:

Binary data is traditionally represented as Base64 encoded strings in
textual formats like XML, JSON and YAML; and this is the defaut format
for many libraries and languages when it comes to serialize binary data
in one of these formats.

Currently cassandra-unit only supports conversion to hexadecimal, which
makes it uneasy to directly re-use existing data for testing purposes
in Cassandra.

With this commit, cassandra-unit tries to be a bit more clever and
detect when binary data is provided as a hexadecimal or a Base64
string, and perform the right conversion.

See also:
- http://yaml.org/type/binary.html
- http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#base64Binary
Default format for binary data is Base64 for Jackson JSON and Python
(non-exhaustive):
- http://www.cowtowncoder.com/blog/archives/2009/10/entry_330.html
- http://docs.python.org/2/library/json.html

** Changelog **:
- Added logic to identify hex and base64 encoded strings
- Base64 decoding done using http://migbase64.sourceforge.net (much
faster than other implementations)
- Unit tests for XML, JSON and YAML
- Integration test in DataLoaderTest
---
 .../exception/CassandraUnitException.java          |   3 +
 .../serializer/GenericTypeSerializer.java          |  27 +-
 src/main/java/org/cassandraunit/utils/Base64.java  | 575 +++++++++++++++++++++
 .../java/org/cassandraunit/DataLoaderTest.java     |  37 ++
 .../dataset/json/ClasspathJsonDataSetTest.java     |  12 +
 .../dataset/xml/ClasspathXmlDataSetTest.java       |  12 +-
 .../dataset/yaml/ClasspathYamlDataSetTest.java     |  21 +
 .../org/cassandraunit/utils/MockDataSetHelper.java |  42 ++
 src/test/resources/json/dataSetWithBinaryData.json |  15 +
 src/test/resources/xml/dataSetWithBinaryData.xml   |  18 +
 src/test/resources/yaml/dataSetWithBinaryData.yaml |  15 +
 11 files changed, 772 insertions(+), 5 deletions(-)
 create mode 100644 src/main/java/org/cassandraunit/utils/Base64.java
 create mode 100644 src/test/resources/json/dataSetWithBinaryData.json
 create mode 100644 src/test/resources/xml/dataSetWithBinaryData.xml
 create mode 100644 src/test/resources/yaml/dataSetWithBinaryData.yaml

diff --git a/src/main/java/org/cassandraunit/exception/CassandraUnitException.java b/src/main/java/org/cassandraunit/exception/CassandraUnitException.java
index 7bfb4b8..88e29c2 100644
--- a/src/main/java/org/cassandraunit/exception/CassandraUnitException.java
+++ b/src/main/java/org/cassandraunit/exception/CassandraUnitException.java
@@ -6,4 +6,7 @@ public class CassandraUnitException extends RuntimeException {
         super(message, cause);
     }
 
+    public CassandraUnitException(String message) {
+        super(message);
+    }
 }
diff --git a/src/main/java/org/cassandraunit/serializer/GenericTypeSerializer.java b/src/main/java/org/cassandraunit/serializer/GenericTypeSerializer.java
index 1f784d4..24e358c 100644
--- a/src/main/java/org/cassandraunit/serializer/GenericTypeSerializer.java
+++ b/src/main/java/org/cassandraunit/serializer/GenericTypeSerializer.java
@@ -18,6 +18,7 @@ import org.apache.commons.codec.binary.Hex;
 import org.cassandraunit.exception.CassandraUnitException;
 import org.cassandraunit.type.GenericType;
 import org.cassandraunit.type.GenericTypeEnum;
+import org.cassandraunit.utils.Base64;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -26,6 +27,7 @@ import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.UUID;
+import java.util.regex.Pattern;
 
 /**
  * @author Jeremy Sevellec
@@ -33,6 +35,8 @@ import java.util.UUID;
 public class GenericTypeSerializer extends AbstractSerializer<GenericType> {
 
     private static final GenericTypeSerializer instance = new GenericTypeSerializer();
+    private static final Pattern hexPattern = Pattern.compile("[0-9abcdefABCDEF]+");
+    private static final Pattern base64Pattern = Pattern.compile("[0-9a-zA-Z/+]+={0,3}");
 
     public static final DateFormat dateFormat = new SimpleDateFormat("yyyyMMdd HHmmss");
 
@@ -70,16 +74,21 @@ public class GenericTypeSerializer extends AbstractSerializer<GenericType> {
                     byteBuffer = BooleanSerializer.get().toByteBuffer(Boolean.parseBoolean(genericValue));
                     break;
                 case BYTES_TYPE:
-                    byte[] hexDecodedBytes;
+                    byte[] decodedBytes;
                     try {
                         if (genericValue.isEmpty()) {
                             byteBuffer = ByteBufferSerializer.get().fromBytes(new byte[0]);
+                        } else if (isHex(genericValue)) {
+                            decodedBytes = Hex.decodeHex(genericValue.toCharArray());
+                            byteBuffer = ByteBufferSerializer.get().fromBytes(decodedBytes);
+                        } else if (isBase64(genericValue)) {
+                            decodedBytes = Base64.decode(genericValue);
+                            byteBuffer = ByteBufferSerializer.get().fromBytes(decodedBytes);
                         } else {
-                            hexDecodedBytes = Hex.decodeHex(genericValue.toCharArray());
-                            byteBuffer = ByteBufferSerializer.get().fromBytes(hexDecodedBytes);
+                            throw new CassandraUnitException("Failed to parse \"" + genericValue + "\" as bytes: unknown binary encoding.");
                         }
                     } catch (DecoderException e) {
-                        throw new CassandraUnitException("cannot parse \"" + genericValue + "\" as hex bytes", e);
+                        throw new CassandraUnitException("Failed to parse \"" + genericValue + "\" as bytes", e);
                     }
                     break;
                 case DATE_TYPE:
@@ -129,6 +138,16 @@ public class GenericTypeSerializer extends AbstractSerializer<GenericType> {
         return byteBuffer;
     }
 
+    private boolean isHex(String genericValue) {
+        return hexPattern.matcher(genericValue).matches();
+    }
+
+    private boolean isBase64(String genericValue) {
+        if (!(genericValue.length() % 4 == 0))
+            return false;
+        return base64Pattern.matcher(genericValue).matches();
+    }
+
     private Composite createComposite(GenericType genericType) {
         if (!GenericTypeEnum.COMPOSITE_TYPE.equals(genericType.getType())) {
             throw new IllegalArgumentException("the generricType must be a CompositeType");
diff --git a/src/main/java/org/cassandraunit/utils/Base64.java b/src/main/java/org/cassandraunit/utils/Base64.java
new file mode 100644
index 0000000..c332162
--- /dev/null
+++ b/src/main/java/org/cassandraunit/utils/Base64.java
@@ -0,0 +1,575 @@
+package org.cassandraunit.utils;
+
+import java.util.Arrays;
+
+/** A very fast and memory efficient class to encode and decode to and from BASE64 in full accordance
+ * with RFC 2045.<br><br>
+ * On Windows XP sp1 with 1.4.2_04 and later ;), this encoder and decoder is about 10 times faster
+ * on small arrays (10 - 1000 bytes) and 2-3 times as fast on larger arrays (10000 - 1000000 bytes)
+ * compared to <code>sun.misc.Encoder()/Decoder()</code>.<br><br>
+ *
+ * On byte arrays the encoder is about 20% faster than Jakarta Commons Base64 Codec for encode and
+ * about 50% faster for decoding large arrays. This implementation is about twice as fast on very small
+ * arrays (&lt 30 bytes). If source/destination is a <code>String</code> this
+ * version is about three times as fast due to the fact that the Commons Codec result has to be recoded
+ * to a <code>String</code> from <code>byte[]</code>, which is very expensive.<br><br>
+ *
+ * This encode/decode algorithm doesn't create any temporary arrays as many other codecs do, it only
+ * allocates the resulting array. This produces less garbage and it is possible to handle arrays twice
+ * as large as algorithms that create a temporary array. (E.g. Jakarta Commons Codec). It is unknown
+ * whether Sun's <code>sun.misc.Encoder()/Decoder()</code> produce temporary arrays but since performance
+ * is quite low it probably does.<br><br>
+ *
+ * The encoder produces the same output as the Sun one except that the Sun's encoder appends
+ * a trailing line separator if the last character isn't a pad. Unclear why but it only adds to the
+ * length and is probably a side effect. Both are in conformance with RFC 2045 though.<br>
+ * Commons codec seem to always att a trailing line separator.<br><br>
+ *
+ * <b>Note!</b>
+ * The encode/decode method pairs (types) come in three versions with the <b>exact</b> same algorithm and
+ * thus a lot of code redundancy. This is to not create any temporary arrays for transcoding to/from different
+ * format types. The methods not used can simply be commented out.<br><br>
+ *
+ * There is also a "fast" version of all decode methods that works the same way as the normal ones, but
+ * har a few demands on the decoded input. Normally though, these fast verions should be used if the source if
+ * the input is known and it hasn't bee tampered with.<br><br>
+ *
+ * If you find the code useful or you find a bug, please send me a note at base64 @ miginfocom . com.
+ *
+ * Licence (BSD):
+ * ==============
+ *
+ * Copyright (c) 2004, Mikael Grev, MiG InfoCom AB. (base64 @ miginfocom . com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright notice, this list
+ * of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ * Neither the name of the MiG InfoCom AB nor the names of its contributors may be
+ * used to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * @version 2.2
+ * @author Mikael Grev
+ *         Date: 2004-aug-02
+ *         Time: 11:31:11
+ */
+
+public class Base64
+{
+	private static final char[] CA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();
+	private static final int[] IA = new int[256];
+	static {
+		Arrays.fill(IA, -1);
+		for (int i = 0, iS = CA.length; i < iS; i++)
+			IA[CA[i]] = i;
+		IA['='] = 0;
+	}
+
+	// ****************************************************************************************
+	// *  char[] version
+	// ****************************************************************************************
+
+	/** Encodes a raw byte array into a BASE64 <code>char[]</code> representation i accordance with RFC 2045.
+	 * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.
+	 * @param lineSep Optional "\r\n" after 76 characters, unless end of file.<br>
+	 * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
+	 * little faster.
+	 * @return A BASE64 encoded array. Never <code>null</code>.
+	 */
+	public final static char[] encodeToChar(byte[] sArr, boolean lineSep)
+	{
+		// Check special case
+		int sLen = sArr != null ? sArr.length : 0;
+		if (sLen == 0)
+			return new char[0];
+
+		int eLen = (sLen / 3) * 3;              // Length of even 24-bits.
+		int cCnt = ((sLen - 1) / 3 + 1) << 2;   // Returned character count
+		int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 << 1 : 0); // Length of returned array
+		char[] dArr = new char[dLen];
+
+		// Encode even 24-bits
+		for (int s = 0, d = 0, cc = 0; s < eLen;) {
+			// Copy next three bytes into lower 24 bits of int, paying attension to sign.
+			int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff);
+
+			// Encode the int into four chars
+			dArr[d++] = CA[(i >>> 18) & 0x3f];
+			dArr[d++] = CA[(i >>> 12) & 0x3f];
+			dArr[d++] = CA[(i >>> 6) & 0x3f];
+			dArr[d++] = CA[i & 0x3f];
+
+			// Add optional line separator
+			if (lineSep && ++cc == 19 && d < dLen - 2) {
+				dArr[d++] = '\r';
+				dArr[d++] = '\n';
+				cc = 0;
+			}
+		}
+
+		// Pad and encode last bits if source isn't even 24 bits.
+		int left = sLen - eLen; // 0 - 2.
+		if (left > 0) {
+			// Prepare the int
+			int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0);
+
+			// Set last four chars
+			dArr[dLen - 4] = CA[i >> 12];
+			dArr[dLen - 3] = CA[(i >>> 6) & 0x3f];
+			dArr[dLen - 2] = left == 2 ? CA[i & 0x3f] : '=';
+			dArr[dLen - 1] = '=';
+		}
+		return dArr;
+	}
+
+	/** Decodes a BASE64 encoded char array. All illegal characters will be ignored and can handle both arrays with
+	 * and without line separators.
+	 * @param sArr The source array. <code>null</code> or length 0 will return an empty array.
+	 * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters
+	 * (including '=') isn't divideable by 4.  (I.e. definitely corrupted).
+	 */
+	public final static byte[] decode(char[] sArr)
+	{
+		// Check special case
+		int sLen = sArr != null ? sArr.length : 0;
+		if (sLen == 0)
+			return new byte[0];
+
+		// Count illegal characters (including '\r', '\n') to know what size the returned array will be,
+		// so we don't have to reallocate & copy it later.
+		int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that's a bonus...)
+		for (int i = 0; i < sLen; i++)  // If input is "pure" (I.e. no line separators or illegal chars) base64 this loop can be commented out.
+			if (IA[sArr[i]] < 0)
+				sepCnt++;
+
+		// Check so that legal chars (including '=') are evenly divideable by 4 as specified in RFC 2045.
+		if ((sLen - sepCnt) % 4 != 0)
+			return null;
+
+		int pad = 0;
+		for (int i = sLen; i > 1 && IA[sArr[--i]] <= 0;)
+			if (sArr[i] == '=')
+				pad++;
+
+		int len = ((sLen - sepCnt) * 6 >> 3) - pad;
+
+		byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
+
+		for (int s = 0, d = 0; d < len;) {
+			// Assemble three bytes into an int from four "valid" characters.
+			int i = 0;
+			for (int j = 0; j < 4; j++) {   // j only increased if a valid char was found.
+				int c = IA[sArr[s++]];
+				if (c >= 0)
+				    i |= c << (18 - j * 6);
+				else
+					j--;
+			}
+			// Add the bytes
+			dArr[d++] = (byte) (i >> 16);
+			if (d < len) {
+				dArr[d++]= (byte) (i >> 8);
+				if (d < len)
+					dArr[d++] = (byte) i;
+			}
+		}
+		return dArr;
+	}
+
+	/** Decodes a BASE64 encoded char array that is known to be resonably well formatted. The method is about twice as
+	 * fast as {@link #decode(char[])}. The preconditions are:<br>
+	 * + The array must have a line length of 76 chars OR no line separators at all (one line).<br>
+	 * + Line separator must be "\r\n", as specified in RFC 2045
+	 * + The array must not contain illegal characters within the encoded string<br>
+	 * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.<br>
+	 * @param sArr The source array. Length 0 will return an empty array. <code>null</code> will throw an exception.
+	 * @return The decoded array of bytes. May be of length 0.
+	 */
+	public final static byte[] decodeFast(char[] sArr)
+	{
+		// Check special case
+		int sLen = sArr.length;
+		if (sLen == 0)
+			return new byte[0];
+
+		int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.
+
+		// Trim illegal chars from start
+		while (sIx < eIx && IA[sArr[sIx]] < 0)
+			sIx++;
+
+		// Trim illegal chars from end
+		while (eIx > 0 && IA[sArr[eIx]] < 0)
+			eIx--;
+
+		// get the padding count (=) (0, 1 or 2)
+		int pad = sArr[eIx] == '=' ? (sArr[eIx - 1] == '=' ? 2 : 1) : 0;  // Count '=' at end.
+		int cCnt = eIx - sIx + 1;   // Content count including possible separators
+		int sepCnt = sLen > 76 ? (sArr[76] == '\r' ? cCnt / 78 : 0) << 1 : 0;
+
+		int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes
+		byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
+
+		// Decode all but the last 0 - 2 bytes.
+		int d = 0;
+		for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {
+			// Assemble three bytes into an int from four "valid" characters.
+			int i = IA[sArr[sIx++]] << 18 | IA[sArr[sIx++]] << 12 | IA[sArr[sIx++]] << 6 | IA[sArr[sIx++]];
+
+			// Add the bytes
+			dArr[d++] = (byte) (i >> 16);
+			dArr[d++] = (byte) (i >> 8);
+			dArr[d++] = (byte) i;
+
+			// If line separator, jump over it.
+			if (sepCnt > 0 && ++cc == 19) {
+				sIx += 2;
+				cc = 0;
+			}
+		}
+
+		if (d < len) {
+			// Decode last 1-3 bytes (incl '=') into 1-3 bytes
+			int i = 0;
+			for (int j = 0; sIx <= eIx - pad; j++)
+				i |= IA[sArr[sIx++]] << (18 - j * 6);
+
+			for (int r = 16; d < len; r -= 8)
+				dArr[d++] = (byte) (i >> r);
+		}
+
+		return dArr;
+	}
+
+	// ****************************************************************************************
+	// *  byte[] version
+	// ****************************************************************************************
+
+	/** Encodes a raw byte array into a BASE64 <code>byte[]</code> representation i accordance with RFC 2045.
+	 * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.
+	 * @param lineSep Optional "\r\n" after 76 characters, unless end of file.<br>
+	 * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
+	 * little faster.
+	 * @return A BASE64 encoded array. Never <code>null</code>.
+	 */
+	public final static byte[] encodeToByte(byte[] sArr, boolean lineSep)
+	{
+		// Check special case
+		int sLen = sArr != null ? sArr.length : 0;
+		if (sLen == 0)
+			return new byte[0];
+
+		int eLen = (sLen / 3) * 3;                              // Length of even 24-bits.
+		int cCnt = ((sLen - 1) / 3 + 1) << 2;                   // Returned character count
+		int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 << 1 : 0); // Length of returned array
+		byte[] dArr = new byte[dLen];
+
+		// Encode even 24-bits
+		for (int s = 0, d = 0, cc = 0; s < eLen;) {
+			// Copy next three bytes into lower 24 bits of int, paying attension to sign.
+			int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff);
+
+			// Encode the int into four chars
+			dArr[d++] = (byte) CA[(i >>> 18) & 0x3f];
+			dArr[d++] = (byte) CA[(i >>> 12) & 0x3f];
+			dArr[d++] = (byte) CA[(i >>> 6) & 0x3f];
+			dArr[d++] = (byte) CA[i & 0x3f];
+
+			// Add optional line separator
+			if (lineSep && ++cc == 19 && d < dLen - 2) {
+				dArr[d++] = '\r';
+				dArr[d++] = '\n';
+				cc = 0;
+			}
+		}
+
+		// Pad and encode last bits if source isn't an even 24 bits.
+		int left = sLen - eLen; // 0 - 2.
+		if (left > 0) {
+			// Prepare the int
+			int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0);
+
+			// Set last four chars
+			dArr[dLen - 4] = (byte) CA[i >> 12];
+			dArr[dLen - 3] = (byte) CA[(i >>> 6) & 0x3f];
+			dArr[dLen - 2] = left == 2 ? (byte) CA[i & 0x3f] : (byte) '=';
+			dArr[dLen - 1] = '=';
+		}
+		return dArr;
+	}
+
+	/** Decodes a BASE64 encoded byte array. All illegal characters will be ignored and can handle both arrays with
+	 * and without line separators.
+	 * @param sArr The source array. Length 0 will return an empty array. <code>null</code> will throw an exception.
+	 * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters
+	 * (including '=') isn't divideable by 4. (I.e. definitely corrupted).
+	 */
+	public final static byte[] decode(byte[] sArr)
+	{
+		// Check special case
+		int sLen = sArr.length;
+
+		// Count illegal characters (including '\r', '\n') to know what size the returned array will be,
+		// so we don't have to reallocate & copy it later.
+		int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that's a bonus...)
+		for (int i = 0; i < sLen; i++)      // If input is "pure" (I.e. no line separators or illegal chars) base64 this loop can be commented out.
+			if (IA[sArr[i] & 0xff] < 0)
+				sepCnt++;
+
+		// Check so that legal chars (including '=') are evenly divideable by 4 as specified in RFC 2045.
+		if ((sLen - sepCnt) % 4 != 0)
+			return null;
+
+		int pad = 0;
+		for (int i = sLen; i > 1 && IA[sArr[--i] & 0xff] <= 0;)
+			if (sArr[i] == '=')
+				pad++;
+
+		int len = ((sLen - sepCnt) * 6 >> 3) - pad;
+
+		byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
+
+		for (int s = 0, d = 0; d < len;) {
+			// Assemble three bytes into an int from four "valid" characters.
+			int i = 0;
+			for (int j = 0; j < 4; j++) {   // j only increased if a valid char was found.
+				int c = IA[sArr[s++] & 0xff];
+				if (c >= 0)
+				    i |= c << (18 - j * 6);
+				else
+					j--;
+			}
+
+			// Add the bytes
+			dArr[d++] = (byte) (i >> 16);
+			if (d < len) {
+				dArr[d++]= (byte) (i >> 8);
+				if (d < len)
+					dArr[d++] = (byte) i;
+			}
+		}
+
+		return dArr;
+	}
+
+
+	/** Decodes a BASE64 encoded byte array that is known to be resonably well formatted. The method is about twice as
+	 * fast as {@link #decode(byte[])}. The preconditions are:<br>
+	 * + The array must have a line length of 76 chars OR no line separators at all (one line).<br>
+	 * + Line separator must be "\r\n", as specified in RFC 2045
+	 * + The array must not contain illegal characters within the encoded string<br>
+	 * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.<br>
+	 * @param sArr The source array. Length 0 will return an empty array. <code>null</code> will throw an exception.
+	 * @return The decoded array of bytes. May be of length 0.
+	 */
+	public final static byte[] decodeFast(byte[] sArr)
+	{
+		// Check special case
+		int sLen = sArr.length;
+		if (sLen == 0)
+			return new byte[0];
+
+		int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.
+
+		// Trim illegal chars from start
+		while (sIx < eIx && IA[sArr[sIx] & 0xff] < 0)
+			sIx++;
+
+		// Trim illegal chars from end
+		while (eIx > 0 && IA[sArr[eIx] & 0xff] < 0)
+			eIx--;
+
+		// get the padding count (=) (0, 1 or 2)
+		int pad = sArr[eIx] == '=' ? (sArr[eIx - 1] == '=' ? 2 : 1) : 0;  // Count '=' at end.
+		int cCnt = eIx - sIx + 1;   // Content count including possible separators
+		int sepCnt = sLen > 76 ? (sArr[76] == '\r' ? cCnt / 78 : 0) << 1 : 0;
+
+		int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes
+		byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
+
+		// Decode all but the last 0 - 2 bytes.
+		int d = 0;
+		for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {
+			// Assemble three bytes into an int from four "valid" characters.
+			int i = IA[sArr[sIx++]] << 18 | IA[sArr[sIx++]] << 12 | IA[sArr[sIx++]] << 6 | IA[sArr[sIx++]];
+
+			// Add the bytes
+			dArr[d++] = (byte) (i >> 16);
+			dArr[d++] = (byte) (i >> 8);
+			dArr[d++] = (byte) i;
+
+			// If line separator, jump over it.
+			if (sepCnt > 0 && ++cc == 19) {
+				sIx += 2;
+				cc = 0;
+			}
+		}
+
+		if (d < len) {
+			// Decode last 1-3 bytes (incl '=') into 1-3 bytes
+			int i = 0;
+			for (int j = 0; sIx <= eIx - pad; j++)
+				i |= IA[sArr[sIx++]] << (18 - j * 6);
+
+			for (int r = 16; d < len; r -= 8)
+				dArr[d++] = (byte) (i >> r);
+		}
+
+		return dArr;
+	}
+
+	// ****************************************************************************************
+	// * String version
+	// ****************************************************************************************
+
+	/** Encodes a raw byte array into a BASE64 <code>String</code> representation i accordance with RFC 2045.
+	 * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.
+	 * @param lineSep Optional "\r\n" after 76 characters, unless end of file.<br>
+	 * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
+	 * little faster.
+	 * @return A BASE64 encoded array. Never <code>null</code>.
+	 */
+	public final static String encodeToString(byte[] sArr, boolean lineSep)
+	{
+		// Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower.
+		return new String(encodeToChar(sArr, lineSep));
+	}
+
+	/** Decodes a BASE64 encoded <code>String</code>. All illegal characters will be ignored and can handle both strings with
+	 * and without line separators.<br>
+	 * <b>Note!</b> It can be up to about 2x the speed to call <code>decode(str.toCharArray())</code> instead. That
+	 * will create a temporary array though. This version will use <code>str.charAt(i)</code> to iterate the string.
+	 * @param str The source string. <code>null</code> or length 0 will return an empty array.
+	 * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters
+	 * (including '=') isn't divideable by 4.  (I.e. definitely corrupted).
+	 */
+	public final static byte[] decode(String str)
+	{
+		// Check special case
+		int sLen = str != null ? str.length() : 0;
+		if (sLen == 0)
+			return new byte[0];
+
+		// Count illegal characters (including '\r', '\n') to know what size the returned array will be,
+		// so we don't have to reallocate & copy it later.
+		int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that's a bonus...)
+		for (int i = 0; i < sLen; i++)  // If input is "pure" (I.e. no line separators or illegal chars) base64 this loop can be commented out.
+			if (IA[str.charAt(i)] < 0)
+				sepCnt++;
+
+		// Check so that legal chars (including '=') are evenly divideable by 4 as specified in RFC 2045.
+		if ((sLen - sepCnt) % 4 != 0)
+			return null;
+
+		// Count '=' at end
+		int pad = 0;
+		for (int i = sLen; i > 1 && IA[str.charAt(--i)] <= 0;)
+			if (str.charAt(i) == '=')
+				pad++;
+
+		int len = ((sLen - sepCnt) * 6 >> 3) - pad;
+
+		byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
+
+		for (int s = 0, d = 0; d < len;) {
+			// Assemble three bytes into an int from four "valid" characters.
+			int i = 0;
+			for (int j = 0; j < 4; j++) {   // j only increased if a valid char was found.
+				int c = IA[str.charAt(s++)];
+				if (c >= 0)
+				    i |= c << (18 - j * 6);
+				else
+					j--;
+			}
+			// Add the bytes
+			dArr[d++] = (byte) (i >> 16);
+			if (d < len) {
+				dArr[d++]= (byte) (i >> 8);
+				if (d < len)
+					dArr[d++] = (byte) i;
+			}
+		}
+		return dArr;
+	}
+
+	/** Decodes a BASE64 encoded string that is known to be resonably well formatted. The method is about twice as
+	 * fast as {@link #decode(String)}. The preconditions are:<br>
+	 * + The array must have a line length of 76 chars OR no line separators at all (one line).<br>
+	 * + Line separator must be "\r\n", as specified in RFC 2045
+	 * + The array must not contain illegal characters within the encoded string<br>
+	 * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.<br>
+	 * @param s The source string. Length 0 will return an empty array. <code>null</code> will throw an exception.
+	 * @return The decoded array of bytes. May be of length 0.
+	 */
+	public final static byte[] decodeFast(String s)
+	{
+		// Check special case
+		int sLen = s.length();
+		if (sLen == 0)
+			return new byte[0];
+
+		int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.
+
+		// Trim illegal chars from start
+		while (sIx < eIx && IA[s.charAt(sIx) & 0xff] < 0)
+			sIx++;
+
+		// Trim illegal chars from end
+		while (eIx > 0 && IA[s.charAt(eIx) & 0xff] < 0)
+			eIx--;
+
+		// get the padding count (=) (0, 1 or 2)
+		int pad = s.charAt(eIx) == '=' ? (s.charAt(eIx - 1) == '=' ? 2 : 1) : 0;  // Count '=' at end.
+		int cCnt = eIx - sIx + 1;   // Content count including possible separators
+		int sepCnt = sLen > 76 ? (s.charAt(76) == '\r' ? cCnt / 78 : 0) << 1 : 0;
+
+		int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes
+		byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
+
+		// Decode all but the last 0 - 2 bytes.
+		int d = 0;
+		for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {
+			// Assemble three bytes into an int from four "valid" characters.
+			int i = IA[s.charAt(sIx++)] << 18 | IA[s.charAt(sIx++)] << 12 | IA[s.charAt(sIx++)] << 6 | IA[s.charAt(sIx++)];
+
+			// Add the bytes
+			dArr[d++] = (byte) (i >> 16);
+			dArr[d++] = (byte) (i >> 8);
+			dArr[d++] = (byte) i;
+
+			// If line separator, jump over it.
+			if (sepCnt > 0 && ++cc == 19) {
+				sIx += 2;
+				cc = 0;
+			}
+		}
+
+		if (d < len) {
+			// Decode last 1-3 bytes (incl '=') into 1-3 bytes
+			int i = 0;
+			for (int j = 0; sIx <= eIx - pad; j++)
+				i |= IA[s.charAt(sIx++)] << (18 - j * 6);
+
+			for (int r = 16; d < len; r -= 8)
+				dArr[d++] = (byte) (i >> r);
+		}
+
+		return dArr;
+	}
+}
\ No newline at end of file
diff --git a/src/test/java/org/cassandraunit/DataLoaderTest.java b/src/test/java/org/cassandraunit/DataLoaderTest.java
index 38dbc54..9c56b45 100644
--- a/src/test/java/org/cassandraunit/DataLoaderTest.java
+++ b/src/test/java/org/cassandraunit/DataLoaderTest.java
@@ -10,6 +10,7 @@ import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
@@ -669,4 +670,40 @@ public class DataLoaderTest {
 				is("org.apache.cassandra.locator.SimpleStrategy"));
 	}
 
+    @Test
+    public void shouldLoadBinaryData() {
+        String clusterName = "TestCluster6";
+        String host = "localhost:9171";
+        DataLoader dataLoader = new DataLoader(clusterName, host);
+
+        try {
+            dataLoader.load(MockDataSetHelper.getMockDataSetWithBinaryData());
+
+			/* verify */
+            Cluster cluster = HFactory.getOrCreateCluster(clusterName, host);
+            Keyspace keyspace = HFactory.createKeyspace("binaryKeyspace", cluster);
+            RangeSlicesQuery<String, String, byte[]> query = HFactory.createRangeSlicesQuery(keyspace, StringSerializer.get(), StringSerializer.get(),
+                    BytesArraySerializer.get());
+            query.setColumnFamily("columnFamilyWithBinaryData");
+            query.setRange(null, null, false, Integer.MAX_VALUE);
+            QueryResult<OrderedRows<String, String, byte[]>> result = query.execute();
+            List<Row<String, String, byte[]>> rows = result.get().getList();
+
+            assertThat(rows.size(), is(1));
+            assertThat(rows.get(0).getKey(), is("row1"));
+            assertThat(rows.get(0).getColumnSlice().getColumns().size(), is(2));
+
+            assertThat(rows.get(0).getColumnSlice().getColumns().get(0), notNullValue());
+            assertThat(rows.get(0).getColumnSlice().getColumns().get(0).getName(), is("a"));
+            assertThat(new String(rows.get(0).getColumnSlice().getColumns().get(0).getValue(), Charset.forName("UTF-8")), is("hello world!"));
+
+            assertThat(rows.get(0).getColumnSlice().getColumns().get(1), notNullValue());
+            assertThat(rows.get(0).getColumnSlice().getColumns().get(1).getName(), is("b"));
+            String expectedValue = "Welcome to Apache Cassandra\r\n\r\nThe Apache Cassandra database is the right choice when you need scalability and high availability without compromising performance. Linear scalability and proven fault-tolerance on commodity hardware or cloud infrastructure make it the perfect platform for mission-critical data. Cassandra's support for replicating across multiple datacenters is best-in-class, providing lower latency for your users and the peace of mind of knowing that you can survive regional outages.";
+            assertThat(new String(rows.get(0).getColumnSlice().getColumns().get(1).getValue(), Charset.forName("UTF-8")), is(expectedValue));
+        } catch (HInvalidRequestException e) {
+            e.printStackTrace();
+            fail();
+        }
+    }
 }
diff --git a/src/test/java/org/cassandraunit/dataset/json/ClasspathJsonDataSetTest.java b/src/test/java/org/cassandraunit/dataset/json/ClasspathJsonDataSetTest.java
index 330eca4..5f6c10e 100644
--- a/src/test/java/org/cassandraunit/dataset/json/ClasspathJsonDataSetTest.java
+++ b/src/test/java/org/cassandraunit/dataset/json/ClasspathJsonDataSetTest.java
@@ -361,4 +361,16 @@ public class ClasspathJsonDataSetTest {
         ColumnMetadataModel columnMetadata = dataSet.getColumnFamilies().get(0).getColumnsMetadata().get(0);
         assertThat(columnMetadata.getColumnName().getType(), is(GenericTypeEnum.TIME_UUID_TYPE));
     }
+
+    @Test
+    public void shouldGetBinaryData() {
+        DataSet dataSet = new ClassPathJsonDataSet("json/dataSetWithBinaryData.json");
+        ColumnFamilyModel columnFamilyModel = dataSet.getColumnFamilies().get(0);
+        assertThat(columnFamilyModel.getName(), is("columnFamilyWithBinaryData"));
+        List<ColumnModel> columns = columnFamilyModel.getRows().get(0).getColumns();
+        ColumnModel column1 = columns.get(0);
+        assertThat(column1.getName().getValue(), is("a"));
+        assertThat(column1.getValue().getValue(), is("aGVsbG8gd29ybGQh"));
+        assertThat(column1.getValue().getType(), is(GenericTypeEnum.BYTES_TYPE));
+    }
 }
diff --git a/src/test/java/org/cassandraunit/dataset/xml/ClasspathXmlDataSetTest.java b/src/test/java/org/cassandraunit/dataset/xml/ClasspathXmlDataSetTest.java
index 5c6cd5b..a1fd4bc 100644
--- a/src/test/java/org/cassandraunit/dataset/xml/ClasspathXmlDataSetTest.java
+++ b/src/test/java/org/cassandraunit/dataset/xml/ClasspathXmlDataSetTest.java
@@ -476,5 +476,15 @@ public class ClasspathXmlDataSetTest {
         assertThat(columnMetadata.getColumnName().getType(), is(GenericTypeEnum.TIME_UUID_TYPE));
     }
 
-
+    @Test
+    public void shouldGetBinaryData() {
+        DataSet dataSet = new ClassPathXmlDataSet("xml/dataSetWithBinaryData.xml");
+        ColumnFamilyModel columnFamilyModel = dataSet.getColumnFamilies().get(0);
+        assertThat(columnFamilyModel.getName(), is("columnFamilyWithBinaryData"));
+        List<ColumnModel> columns = columnFamilyModel.getRows().get(0).getColumns();
+        ColumnModel column1 = columns.get(0);
+        assertThat(column1.getName().getValue(), is("a"));
+        assertThat(column1.getValue().getValue(), is("aGVsbG8gd29ybGQh"));
+        assertThat(column1.getValue().getType(), is(GenericTypeEnum.BYTES_TYPE));
+    }
 }
diff --git a/src/test/java/org/cassandraunit/dataset/yaml/ClasspathYamlDataSetTest.java b/src/test/java/org/cassandraunit/dataset/yaml/ClasspathYamlDataSetTest.java
index 23ea73b..63320bd 100644
--- a/src/test/java/org/cassandraunit/dataset/yaml/ClasspathYamlDataSetTest.java
+++ b/src/test/java/org/cassandraunit/dataset/yaml/ClasspathYamlDataSetTest.java
@@ -364,4 +364,25 @@ public class ClasspathYamlDataSetTest {
         assertThat(column3.getValue().getType(),is(GenericTypeEnum.UTF_8_TYPE));
     }
 
+    @Test
+    public void shouldGetBinaryData() {
+        DataSet dataSet = new ClassPathYamlDataSet("yaml/dataSetWithBinaryData.yaml");
+        ColumnFamilyModel columnFamilyModel = dataSet.getColumnFamilies().get(0);
+        assertThat(columnFamilyModel.getName(), is("columnFamilyWithBinaryData"));
+        List<ColumnModel> columns = columnFamilyModel.getRows().get(0).getColumns();
+        ColumnModel column1 = columns.get(0);
+        assertThat(column1.getName().getValue(), is("a"));
+        assertThat(column1.getValue().getValue(), is("aGVsbG8gd29ybGQh"));
+        assertThat(column1.getValue().getType(), is(GenericTypeEnum.BYTES_TYPE));
+
+        ColumnModel column2 = columns.get(1);
+        assertThat(column2.getName().getValue(), is("b"));
+        assertThat(column2.getValue().getValue(), is("aGVsbG8gd29ybGQh"));
+        assertThat(column2.getValue().getType(), is(GenericTypeEnum.BYTES_TYPE));
+
+        ColumnModel column3 = columns.get(2);
+        assertThat(column3.getName().getValue(), is("c"));
+        assertThat(column3.getValue().getValue(), is("aGVsbG8gd29ybGQh"));
+        assertThat(column3.getValue().getType(), is(GenericTypeEnum.BYTES_TYPE));
+    }
 }
diff --git a/src/test/java/org/cassandraunit/utils/MockDataSetHelper.java b/src/test/java/org/cassandraunit/utils/MockDataSetHelper.java
index dbb9090..5813159 100644
--- a/src/test/java/org/cassandraunit/utils/MockDataSetHelper.java
+++ b/src/test/java/org/cassandraunit/utils/MockDataSetHelper.java
@@ -712,4 +712,46 @@ public class MockDataSetHelper {
         return mockDataSet;
     }
 
+
+    public static DataSet getMockDataSetWithBinaryData() {
+        DataSet mockDataSet = mock(DataSet.class);
+        KeyspaceModel keyspace = new KeyspaceModel();
+        keyspace.setName("binaryKeyspace");
+        keyspace.getColumnFamilies();
+
+        /* column family */
+        ColumnFamilyModel columnFamily = new ColumnFamilyModel();
+        columnFamily.setName("columnFamilyWithBinaryData");
+        columnFamily.setKeyType(ComparatorType.UTF8TYPE);
+        columnFamily.setDefaultColumnValueType(ComparatorType.BYTESTYPE);
+
+        /* row1 */
+        RowModel row = new RowModel();
+        row.setKey(new GenericType("row1", GenericTypeEnum.UTF_8_TYPE));
+
+        /* column1 */
+        ColumnModel column1 = new ColumnModel();
+        column1.setName(new GenericType("a", GenericTypeEnum.UTF_8_TYPE));
+        column1.setValue(new GenericType("aGVsbG8gd29ybGQh", GenericTypeEnum.BYTES_TYPE));
+        row.getColumns().add(column1);
+
+        /* column2 */
+        ColumnModel column2 = new ColumnModel();
+        column2.setName(new GenericType("b", GenericTypeEnum.UTF_8_TYPE));
+        String value2 = "V2VsY29tZSB0byBBcGFjaGUgQ2Fzc2FuZHJhDQoNClRoZSBBcGFjaGUgQ2Fzc2FuZHJhIGRhdGFiYXNlIGlzIHRoZSByaWdodCBjaG9pY2Ugd2hlbiB5b3UgbmVlZCBzY2FsYWJpbGl0eSBhbmQgaGln" +
+            "aCBhdmFpbGFiaWxpdHkgd2l0aG91dCBjb21wcm9taXNpbmcgcGVyZm9ybWFuY2UuIExpbmVhciBzY2FsYWJpbGl0eSBhbmQgcHJvdmVuIGZhdWx0LXRvbGVyYW5jZSBvbiBjb21tb2RpdHkgaGFyZHdh" +
+            "cmUgb3IgY2xvdWQgaW5mcmFzdHJ1Y3R1cmUgbWFrZSBpdCB0aGUgcGVyZmVjdCBwbGF0Zm9ybSBmb3IgbWlzc2lvbi1jcml0aWNhbCBkYXRhLiBDYXNzYW5kcmEncyBzdXBwb3J0IGZvciByZXBsaWNh" +
+            "dGluZyBhY3Jvc3MgbXVsdGlwbGUgZGF0YWNlbnRlcnMgaXMgYmVzdC1pbi1jbGFzcywgcHJvdmlkaW5nIGxvd2VyIGxhdGVuY3kgZm9yIHlvdXIgdXNlcnMgYW5kIHRoZSBwZWFjZSBvZiBtaW5kIG9m" +
+            "IGtub3dpbmcgdGhhdCB5b3UgY2FuIHN1cnZpdmUgcmVnaW9uYWwgb3V0YWdlcy4=";
+        column2.setValue(new GenericType(value2, GenericTypeEnum.BYTES_TYPE));
+        row.getColumns().add(column2);
+
+        columnFamily.getRows().add(row);
+        keyspace.getColumnFamilies().add(columnFamily);
+
+        when(mockDataSet.getKeyspace()).thenReturn(keyspace);
+        when(mockDataSet.getColumnFamilies()).thenReturn(keyspace.getColumnFamilies());
+
+        return mockDataSet;
+    }
 }
diff --git a/src/test/resources/json/dataSetWithBinaryData.json b/src/test/resources/json/dataSetWithBinaryData.json
new file mode 100644
index 0000000..c1b99b6
--- /dev/null
+++ b/src/test/resources/json/dataSetWithBinaryData.json
@@ -0,0 +1,15 @@
+{
+    "name" : "binaryKeyspace",
+	"columnFamilies" : [{
+        "name" : "columnFamilyWithBinaryData",
+		"comparatorType" : "UTF8Type",
+		"defaultColumnValueType" : "BytesType",
+        "rows" : [{
+            "key" : "row1",
+            "columns" : [{
+                "name" : "a",
+                "value" : "aGVsbG8gd29ybGQh"
+            }]
+        }]
+    }]
+}
diff --git a/src/test/resources/xml/dataSetWithBinaryData.xml b/src/test/resources/xml/dataSetWithBinaryData.xml
new file mode 100644
index 0000000..472b8b8
--- /dev/null
+++ b/src/test/resources/xml/dataSetWithBinaryData.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<keyspace xmlns="http://xml.dataset.cassandraunit.org">
+	<name>binaryKeyspace</name>
+	<columnFamilies>
+		<columnFamily>
+			<name>columnFamilyWithBinaryData</name>
+			<comparatorType>UTF8Type</comparatorType>
+            <defaultColumnValueType>BytesType</defaultColumnValueType>
+			<row>
+				<key>row1</key>
+				<column>
+					<name>a</name>
+					<value>aGVsbG8gd29ybGQh</value>
+				</column>
+			</row>
+		</columnFamily>
+	</columnFamilies>
+</keyspace>
\ No newline at end of file
diff --git a/src/test/resources/yaml/dataSetWithBinaryData.yaml b/src/test/resources/yaml/dataSetWithBinaryData.yaml
new file mode 100644
index 0000000..e605676
--- /dev/null
+++ b/src/test/resources/yaml/dataSetWithBinaryData.yaml
@@ -0,0 +1,15 @@
+name: binaryKeyspace
+replicationFactor: 1
+strategy: org.apache.cassandra.locator.SimpleStrategy
+columnFamilies:
+- name: columnFamilyWithBinaryData
+  type: STANDARD
+  keyType: UTF8Type
+  comparatorType: UTF8Type
+  defaultColumnValueType: BytesType
+  rows:
+  - key: row1
+    columns:
+    - {name: a, value: "aGVsbG8gd29ybGQh"}
+    - {name: b, value: aGVsbG8gd29ybGQh}
+    - {name: c, value: bytes(aGVsbG8gd29ybGQh)}
\ No newline at end of file
-- 
1.8.1

